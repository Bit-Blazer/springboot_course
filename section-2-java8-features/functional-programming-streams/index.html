
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Functional Programming &amp; Streams API</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/styles/monokai.min.css">
  <link rel="stylesheet" href="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics ga4id="G-XXXXXXXXXX"></google-codelab-analytics>
  <google-codelab codelab-ga4id="G-4LV2JBSBPM"
                  id="functional-programming-streams"
                  title="Functional Programming &amp; Streams API"
                  environment="web"
                  feedback-link="https://github.com/Bit-Blazer/springboot_course/issues/new">
    
      <google-codelab-step label="Introduction" duration="5">
        <p>Welcome to the world of functional programming in Java! Java 8 introduced a paradigm shift with lambda expressions and the Stream API, enabling you to write more concise, expressive, and maintainable code.</p>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<ul class="checklist">
<li>Functional programming concepts and paradigm shift</li>
<li>Lambda expressions syntax and best practices</li>
<li>Functional interfaces (Predicate, Function, Consumer, Supplier, BiFunction)</li>
<li>Method references (static, instance, constructor)</li>
<li>Stream API creation and pipeline operations</li>
<li>Intermediate operations (filter, map, flatMap, sorted, distinct)</li>
<li>Terminal operations (collect, forEach, reduce, count)</li>
<li>Collectors (toList, toSet, toMap, groupingBy, partitioningBy)</li>
<li>Parallel streams and performance considerations</li>
</ul>
<h2 is-upgraded>What You&#39;ll Build</h2>
<p>A comprehensive <strong>Sales Analytics Application</strong> featuring:</p>
<ul>
<li>Sales data processing with functional style</li>
<li>Complex filtering and transformations</li>
<li>Statistical analysis using collectors</li>
<li>Revenue calculations and grouping</li>
<li>Performance comparison: imperative vs functional</li>
<li>Parallel stream processing demonstration</li>
</ul>
<h2 is-upgraded>Prerequisites</h2>
<ul>
<li>Completed Codelab 1.4 (Collections &amp; Generics)</li>
<li>Understanding of interfaces and anonymous classes</li>
<li>Basic knowledge of data structures</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Understanding Functional Programming" duration="8">
        <p>Functional programming treats computation as the evaluation of mathematical functions, avoiding changing state and mutable data.</p>
<h2 is-upgraded>Imperative vs Functional Style</h2>
<p><strong>Imperative Approach (Traditional Java):</strong></p>
<pre><code language="language-java" class="language-java">List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;, &#34;David&#34;);
List&lt;String&gt; result = new ArrayList&lt;&gt;();

for (String name : names) {
    if (name.length() &gt; 3) {
        result.add(name.toUpperCase());
    }
}

Collections.sort(result);
System.out.println(result);
</code></pre>
<p><strong>Functional Approach (Java 8+):</strong></p>
<pre><code language="language-java" class="language-java">List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;, &#34;David&#34;);

List&lt;String&gt; result = names.stream()
    .filter(name -&gt; name.length() &gt; 3)
    .map(String::toUpperCase)
    .sorted()
    .collect(Collectors.toList());

System.out.println(result);
</code></pre>
<aside class="special"><p><strong>Key Difference:</strong> Functional style describes <strong>what</strong> you want, not <strong>how</strong> to do it. It&#39;s declarative, not imperative.</p>
</aside>
<h2 is-upgraded>Core Principles</h2>
<p><strong>1. Immutability:</strong></p>
<pre><code language="language-java" class="language-java">// Immutable approach
List&lt;Integer&gt; numbers = List.of(1, 2, 3, 4, 5);
List&lt;Integer&gt; doubled = numbers.stream()
    .map(n -&gt; n * 2)
    .collect(Collectors.toList());
// Original list unchanged
</code></pre>
<p><strong>2. Pure Functions:</strong></p>
<pre><code language="language-java" class="language-java">// Pure function - no side effects, same input = same output
Function&lt;Integer, Integer&gt; square = x -&gt; x * x;
System.out.println(square.apply(5));  // Always 25
</code></pre>
<p><strong>3. First-Class Functions:</strong></p>
<pre><code language="language-java" class="language-java">// Functions as arguments
public static void processData(List&lt;Integer&gt; data, Function&lt;Integer, Integer&gt; operation) {
    data.forEach(item -&gt; System.out.println(operation.apply(item)));
}

// Pass function as argument
processData(Arrays.asList(1, 2, 3), x -&gt; x * 2);
</code></pre>
<h2 is-upgraded>Benefits</h2>
<ul>
<li><strong>Conciseness:</strong> Less boilerplate code</li>
<li><strong>Readability:</strong> Clear intent, self-documenting</li>
<li><strong>Testability:</strong> Pure functions are easy to test</li>
<li><strong>Parallelization:</strong> Easy to run operations in parallel</li>
<li><strong>Maintainability:</strong> Fewer bugs from mutable state</li>
</ul>
<aside class="warning"><p><strong>Learning Curve:</strong> Functional style requires a mindset shift. It may feel unfamiliar at first, but becomes natural with practice.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Lambda Expressions" duration="10">
        <p>Lambda expressions provide a clear and concise way to represent a method interface using an expression.</p>
<h2 is-upgraded>Syntax</h2>
<p><strong>Basic Structure:</strong></p>
<pre><code language="language-java" class="language-java">(parameters) -&gt; expression
(parameters) -&gt; { statements; }
</code></pre>
<p><strong>Examples:</strong></p>
<pre><code language="language-java" class="language-java">// No parameters
() -&gt; System.out.println(&#34;Hello&#34;)
() -&gt; 42

// Single parameter (parentheses optional)
x -&gt; x * x
(x) -&gt; x * x

// Multiple parameters
(x, y) -&gt; x + y
(x, y) -&gt; {
    int sum = x + y;
    return sum;
}

// Type declarations (optional)
(int x, int y) -&gt; x + y
(String s) -&gt; s.length()
</code></pre>
<h2 is-upgraded>Lambda vs Anonymous Class</h2>
<p><strong>Anonymous Class (Old Way):</strong></p>
<pre><code language="language-java" class="language-java">Runnable runnable = new Runnable() {
    @Override
    public void run() {
        System.out.println(&#34;Running...&#34;);
    }
};
</code></pre>
<p><strong>Lambda Expression (Modern Way):</strong></p>
<pre><code language="language-java" class="language-java">Runnable runnable = () -&gt; System.out.println(&#34;Running...&#34;);
</code></pre>
<h2 is-upgraded>Practical Examples</h2>
<pre><code language="language-java" class="language-java">import java.util.*;
import java.util.function.*;

public class LambdaExamples {
    public static void main(String[] args) {
        // Example 1: Sorting with lambda
        List&lt;String&gt; names = Arrays.asList(&#34;Charlie&#34;, &#34;Alice&#34;, &#34;Bob&#34;);
        names.sort((a, b) -&gt; a.compareTo(b));
        System.out.println(&#34;Sorted: &#34; + names);

        // Example 2: Filtering with lambda
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6);
        numbers.removeIf(n -&gt; n % 2 == 0);  // Remove even numbers
        System.out.println(&#34;Odd numbers: &#34; + numbers);

        // Example 3: forEach with lambda
        Map&lt;String, Integer&gt; ages = new HashMap&lt;&gt;();
        ages.put(&#34;Alice&#34;, 25);
        ages.put(&#34;Bob&#34;, 30);
        ages.forEach((name, age) -&gt;
            System.out.println(name + &#34; is &#34; + age + &#34; years old&#34;)
        );

        // Example 4: Thread with lambda
        Thread thread = new Thread(() -&gt; {
            for (int i = 0; i &lt; 5; i++) {
                System.out.println(&#34;Count: &#34; + i);
            }
        });
        thread.start();
    }
}
</code></pre>
<h2 is-upgraded>Variable Capture</h2>
<p>Lambdas can access variables from the enclosing scope:</p>
<pre><code language="language-java" class="language-java">String prefix = &#34;Message: &#34;;
List&lt;String&gt; messages = Arrays.asList(&#34;Hello&#34;, &#34;World&#34;);

messages.forEach(msg -&gt; System.out.println(prefix + msg));
// Outputs: Message: Hello, Message: World
</code></pre>
<aside class="warning"><p><strong>Important:</strong> Captured variables must be <strong>effectively final</strong> (never reassigned after initialization).</p>
</aside>
<pre><code language="language-java" class="language-java">int count = 0;
messages.forEach(msg -&gt; {
    // count++;  // ERROR! Cannot modify captured variable
    System.out.println(msg);
});
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Functional Interfaces" duration="12">
        <p>A functional interface has exactly one abstract method and can be used as the target for lambda expressions.</p>
<h2 is-upgraded>Built-in Functional Interfaces</h2>
<p>Java provides many functional interfaces in <code>java.util.function</code>:</p>
<p><strong>1. Predicate&lt;T&gt; - Boolean Test</strong></p>
<pre><code language="language-java" class="language-java">import java.util.function.Predicate;

Predicate&lt;Integer&gt; isEven = n -&gt; n % 2 == 0;
Predicate&lt;String&gt; isLong = s -&gt; s.length() &gt; 5;

System.out.println(isEven.test(4));    // true
System.out.println(isLong.test(&#34;Hi&#34;)); // false

// Combining predicates
Predicate&lt;Integer&gt; isPositive = n -&gt; n &gt; 0;
Predicate&lt;Integer&gt; isPositiveEven = isEven.and(isPositive);

System.out.println(isPositiveEven.test(4));   // true
System.out.println(isPositiveEven.test(-4));  // false
</code></pre>
<p><strong>2. Function&lt;T, R&gt; - Transform Input to Output</strong></p>
<pre><code language="language-java" class="language-java">import java.util.function.Function;

Function&lt;String, Integer&gt; strLength = s -&gt; s.length();
Function&lt;Integer, Integer&gt; square = n -&gt; n * n;

System.out.println(strLength.apply(&#34;Hello&#34;));  // 5
System.out.println(square.apply(5));           // 25

// Chaining functions
Function&lt;String, Integer&gt; strLengthSquared = strLength.andThen(square);
System.out.println(strLengthSquared.apply(&#34;Hi&#34;));  // 4 (length=2, squared=4)
</code></pre>
<p><strong>3. Consumer&lt;T&gt; - Accept Input, No Return</strong></p>
<pre><code language="language-java" class="language-java">import java.util.function.Consumer;

Consumer&lt;String&gt; printer = s -&gt; System.out.println(s);
Consumer&lt;String&gt; upperPrinter = s -&gt; System.out.println(s.toUpperCase());

printer.accept(&#34;hello&#34;);       // hello
upperPrinter.accept(&#34;hello&#34;);  // HELLO

// Chaining consumers
Consumer&lt;String&gt; combined = printer.andThen(upperPrinter);
combined.accept(&#34;test&#34;);
// Output:
// test
// TEST
</code></pre>
<p><strong>4. Supplier&lt;T&gt; - Provide Value, No Input</strong></p>
<pre><code language="language-java" class="language-java">import java.util.function.Supplier;

Supplier&lt;Double&gt; randomValue = () -&gt; Math.random();
Supplier&lt;String&gt; greeting = () -&gt; &#34;Hello, World!&#34;;

System.out.println(randomValue.get());  // 0.123456...
System.out.println(greeting.get());     // Hello, World!

// Lazy evaluation
Supplier&lt;List&lt;String&gt;&gt; expensiveOperation = () -&gt; {
    System.out.println(&#34;Computing...&#34;);
    return Arrays.asList(&#34;Result1&#34;, &#34;Result2&#34;);
};

// Not computed yet
List&lt;String&gt; result = expensiveOperation.get();  // Now computed
</code></pre>
<p><strong>5. BiFunction&lt;T, U, R&gt; - Two Inputs, One Output</strong></p>
<pre><code language="language-java" class="language-java">import java.util.function.BiFunction;

BiFunction&lt;Integer, Integer, Integer&gt; add = (a, b) -&gt; a + b;
BiFunction&lt;String, String, String&gt; concat = (s1, s2) -&gt; s1 + s2;

System.out.println(add.apply(5, 3));           // 8
System.out.println(concat.apply(&#34;Hi&#34;, &#34;!&#34;));   // Hi!
</code></pre>
<h2 is-upgraded>Custom Functional Interface</h2>
<pre><code language="language-java" class="language-java">@FunctionalInterface
public interface Calculator {
    int calculate(int a, int b);

    // Default methods allowed
    default void printResult(int a, int b) {
        System.out.println(&#34;Result: &#34; + calculate(a, b));
    }
}

public class FunctionalInterfaceDemo {
    public static void main(String[] args) {
        Calculator add = (a, b) -&gt; a + b;
        Calculator multiply = (a, b) -&gt; a * b;

        System.out.println(add.calculate(5, 3));       // 8
        System.out.println(multiply.calculate(5, 3));  // 15

        add.printResult(10, 20);  // Result: 30
    }
}
</code></pre>
<aside class="special"><p><strong>@FunctionalInterface:</strong> This annotation is optional but recommended. It ensures the interface has exactly one abstract method.</p>
</aside>
<h2 is-upgraded>Functional Interface Reference Table</h2>
<table>
<tr><td colspan="1" rowspan="1"><p>Interface</p>
</td><td colspan="1" rowspan="1"><p>Method Signature</p>
</td><td colspan="1" rowspan="1"><p>Use Case</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>Predicate<T></code></p>
</td><td colspan="1" rowspan="1"><p><code>boolean test(T t)</code></p>
</td><td colspan="1" rowspan="1"><p>Testing conditions</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>Function<T,R></code></p>
</td><td colspan="1" rowspan="1"><p><code>R apply(T t)</code></p>
</td><td colspan="1" rowspan="1"><p>Transforming data</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>Consumer<T></code></p>
</td><td colspan="1" rowspan="1"><p><code>void accept(T t)</code></p>
</td><td colspan="1" rowspan="1"><p>Processing/printing</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>Supplier<T></code></p>
</td><td colspan="1" rowspan="1"><p><code>T get()</code></p>
</td><td colspan="1" rowspan="1"><p>Generating/providing</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>BiFunction<T,U,R></code></p>
</td><td colspan="1" rowspan="1"><p><code>R apply(T t, U u)</code></p>
</td><td colspan="1" rowspan="1"><p>Two-arg operations</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>UnaryOperator<T></code></p>
</td><td colspan="1" rowspan="1"><p><code>T apply(T t)</code></p>
</td><td colspan="1" rowspan="1"><p>Same type transform</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p><code>BinaryOperator<T></code></p>
</td><td colspan="1" rowspan="1"><p><code>T apply(T t1, T t2)</code></p>
</td><td colspan="1" rowspan="1"><p>Combining same types</p>
</td></tr>
</table>


      </google-codelab-step>
    
      <google-codelab-step label="Method References" duration="8">
        <p>Method references are shorthand notation for lambda expressions that call a specific method.</p>
<h2 is-upgraded>Syntax: <code>::</code></h2>
<p><strong>Four Types of Method References:</strong></p>
<h2 is-upgraded>1. Static Method Reference</h2>
<pre><code language="language-java" class="language-java">// Lambda
Function&lt;String, Integer&gt; parser1 = s -&gt; Integer.parseInt(s);

// Method reference
Function&lt;String, Integer&gt; parser2 = Integer::parseInt;

System.out.println(parser2.apply(&#34;123&#34;));  // 123
</code></pre>
<p><strong>More Examples:</strong></p>
<pre><code language="language-java" class="language-java">// Math static methods
List&lt;Double&gt; numbers = Arrays.asList(-1.5, 2.3, -3.7);
numbers.stream()
    .map(Math::abs)  // Static method reference
    .forEach(System.out::println);

// Custom static method
public class StringUtils {
    public static boolean isNotEmpty(String s) {
        return s != null &amp;&amp; !s.isEmpty();
    }
}

List&lt;String&gt; strings = Arrays.asList(&#34;&#34;, &#34;Hello&#34;, null, &#34;World&#34;);
long count = strings.stream()
    .filter(StringUtils::isNotEmpty)
    .count();
</code></pre>
<h2 is-upgraded>2. Instance Method Reference (Specific Object)</h2>
<pre><code language="language-java" class="language-java">String prefix = &#34;Item: &#34;;

// Lambda
Consumer&lt;String&gt; printer1 = s -&gt; System.out.println(prefix + s);

// Method reference
System.out println  // Output stream instance
Consumer&lt;String&gt; printer2 = System.out::println;

List&lt;String&gt; items = Arrays.asList(&#34;Apple&#34;, &#34;Banana&#34;, &#34;Cherry&#34;);
items.forEach(System.out::println);
</code></pre>
<h2 is-upgraded>3. Instance Method Reference (Arbitrary Object)</h2>
<pre><code language="language-java" class="language-java">// Lambda
Function&lt;String, String&gt; upper1 = s -&gt; s.toUpperCase();

// Method reference
Function&lt;String, String&gt; upper2 = String::toUpperCase;

List&lt;String&gt; words = Arrays.asList(&#34;hello&#34;, &#34;world&#34;);
words.stream()
    .map(String::toUpperCase)  // Called on each element
    .forEach(System.out::println);
</code></pre>
<p><strong>Comparison Method:</strong></p>
<pre><code language="language-java" class="language-java">List&lt;String&gt; names = Arrays.asList(&#34;Charlie&#34;, &#34;Alice&#34;, &#34;Bob&#34;);

// Lambda
names.sort((a, b) -&gt; a.compareToIgnoreCase(b));

// Method reference
names.sort(String::compareToIgnoreCase);
</code></pre>
<h2 is-upgraded>4. Constructor Reference</h2>
<pre><code language="language-java" class="language-java">// Lambda
Supplier&lt;List&lt;String&gt;&gt; listSupplier1 = () -&gt; new ArrayList&lt;&gt;();

// Constructor reference
Supplier&lt;List&lt;String&gt;&gt; listSupplier2 = ArrayList::new;

List&lt;String&gt; list = listSupplier2.get();
</code></pre>
<p><strong>With Parameters:</strong></p>
<pre><code language="language-java" class="language-java">// Single parameter constructor
Function&lt;String, Integer&gt; intCreator = Integer::new;
Integer num = intCreator.apply(&#34;123&#34;);  // Creates Integer from String

// Array constructor
IntFunction&lt;int[]&gt; arrayCreator = int[]::new;
int[] array = arrayCreator.apply(10);  // Creates int[10]
</code></pre>
<h2 is-upgraded>Practical Examples</h2>
<pre><code language="language-java" class="language-java">import java.util.*;
import java.util.stream.*;

public class MethodReferenceDemo {
    public static void main(String[] args) {
        List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;bob&#34;, &#34;CHARLIE&#34;);

        // 1. Static method reference
        List&lt;Integer&gt; numbers = Arrays.asList(&#34;1&#34;, &#34;2&#34;, &#34;3&#34;).stream()
            .map(Integer::parseInt)
            .collect(Collectors.toList());

        // 2. Instance method (specific object)
        names.forEach(System.out::println);

        // 3. Instance method (arbitrary object)
        List&lt;String&gt; upperNames = names.stream()
            .map(String::toUpperCase)
            .collect(Collectors.toList());

        // 4. Constructor reference
        Set&lt;String&gt; nameSet = names.stream()
            .collect(Collectors.toCollection(HashSet::new));

        // Comparison with method reference
        names.sort(String::compareToIgnoreCase);
        System.out.println(&#34;Sorted: &#34; + names);
    }
}
</code></pre>
<aside class="special"><p><strong>When to Use:</strong> Method references make code more readable when the lambda simply calls an existing method. Use lambdas for more complex logic.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Stream API Basics" duration="12">
        <p>Streams represent a sequence of elements and support various operations to process data in a functional style.</p>
<h2 is-upgraded>Stream Creation</h2>
<pre><code language="language-java" class="language-java">import java.util.stream.*;
import java.util.*;

// From collection
List&lt;String&gt; list = Arrays.asList(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;);
Stream&lt;String&gt; stream1 = list.stream();

// From array
String[] array = {&#34;a&#34;, &#34;b&#34;, &#34;c&#34;};
Stream&lt;String&gt; stream2 = Arrays.stream(array);

// Using Stream.of()
Stream&lt;String&gt; stream3 = Stream.of(&#34;a&#34;, &#34;b&#34;, &#34;c&#34;);

// Empty stream
Stream&lt;String&gt; empty = Stream.empty();

// Infinite streams
Stream&lt;Integer&gt; infinite = Stream.iterate(0, n -&gt; n + 2);  // 0, 2, 4, 6...
Stream&lt;Double&gt; randoms = Stream.generate(Math::random);

// Numeric streams
IntStream intStream = IntStream.range(1, 10);        // 1 to 9
LongStream longStream = LongStream.rangeClosed(1, 10);  // 1 to 10
DoubleStream doubleStream = DoubleStream.of(1.0, 2.0, 3.0);

// From string
IntStream charStream = &#34;Hello&#34;.chars();  // Stream of char codes
</code></pre>
<h2 is-upgraded>Stream Pipeline</h2>
<p>A stream pipeline consists of:</p>
<ol type="1">
<li><strong>Source</strong> - Where data comes from</li>
<li><strong>Intermediate Operations</strong> - Transform the stream (lazy)</li>
<li><strong>Terminal Operation</strong> - Produces result (triggers execution)</li>
</ol>
<pre><code>Source → filter → map → sorted → collect
         (intermediate ops)      (terminal)
</code></pre>
<h2 is-upgraded>Basic Stream Operations</h2>
<pre><code language="language-java" class="language-java">import java.util.*;
import java.util.stream.*;

public class StreamBasics {
    public static void main(String[] args) {
        List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

        // Filter - keep elements matching condition
        List&lt;Integer&gt; evens = numbers.stream()
            .filter(n -&gt; n % 2 == 0)
            .collect(Collectors.toList());
        System.out.println(&#34;Evens: &#34; + evens);  // [2, 4, 6, 8, 10]

        // Map - transform each element
        List&lt;Integer&gt; squared = numbers.stream()
            .map(n -&gt; n * n)
            .collect(Collectors.toList());
        System.out.println(&#34;Squared: &#34; + squared);

        // Limit - take first N elements
        List&lt;Integer&gt; firstThree = numbers.stream()
            .limit(3)
            .collect(Collectors.toList());
        System.out.println(&#34;First 3: &#34; + firstThree);  // [1, 2, 3]

        // Skip - skip first N elements
        List&lt;Integer&gt; afterFive = numbers.stream()
            .skip(5)
            .collect(Collectors.toList());
        System.out.println(&#34;After 5: &#34; + afterFive);  // [6, 7, 8, 9, 10]

        // Distinct - remove duplicates
        List&lt;Integer&gt; duplicates = Arrays.asList(1, 2, 2, 3, 3, 3);
        List&lt;Integer&gt; unique = duplicates.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println(&#34;Unique: &#34; + unique);  // [1, 2, 3]

        // Sorted - natural order
        List&lt;Integer&gt; shuffled = Arrays.asList(5, 2, 8, 1, 9);
        List&lt;Integer&gt; sorted = shuffled.stream()
            .sorted()
            .collect(Collectors.toList());
        System.out.println(&#34;Sorted: &#34; + sorted);  // [1, 2, 5, 8, 9]

        // Sorted with comparator
        List&lt;String&gt; names = Arrays.asList(&#34;Charlie&#34;, &#34;Alice&#34;, &#34;Bob&#34;);
        List&lt;String&gt; sortedNames = names.stream()
            .sorted(Comparator.reverseOrder())
            .collect(Collectors.toList());
        System.out.println(&#34;Reverse: &#34; + sortedNames);
    }
}
</code></pre>
<h2 is-upgraded>Peek - Debugging</h2>
<pre><code language="language-java" class="language-java">List&lt;Integer&gt; result = numbers.stream()
    .peek(n -&gt; System.out.println(&#34;Original: &#34; + n))
    .filter(n -&gt; n % 2 == 0)
    .peek(n -&gt; System.out.println(&#34;After filter: &#34; + n))
    .map(n -&gt; n * n)
    .peek(n -&gt; System.out.println(&#34;After map: &#34; + n))
    .collect(Collectors.toList());
</code></pre>
<aside class="special"><p><strong>Peek vs forEach:</strong> Use <code>peek()</code> for debugging (intermediate), <code>forEach()</code> for final actions (terminal).</p>
</aside>
<h2 is-upgraded>Lazy Evaluation</h2>
<p>Intermediate operations are lazy - they don&#39;t execute until a terminal operation is called:</p>
<pre><code language="language-java" class="language-java">Stream&lt;Integer&gt; stream = numbers.stream()
    .filter(n -&gt; {
        System.out.println(&#34;Filtering: &#34; + n);
        return n % 2 == 0;
    })
    .map(n -&gt; {
        System.out.println(&#34;Mapping: &#34; + n);
        return n * 2;
    });

System.out.println(&#34;Stream created, but nothing printed yet!&#34;);

// Terminal operation triggers execution
List&lt;Integer&gt; result = stream.collect(Collectors.toList());
</code></pre>
<aside class="warning"><p><strong>One-Time Use:</strong> Streams can only be used once. After a terminal operation, the stream is consumed and cannot be reused.</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Intermediate Operations" duration="10">
        <p>Intermediate operations transform a stream and return another stream, allowing chaining.</p>
<h2 is-upgraded>filter()</h2>
<p>Keep elements matching a predicate:</p>
<pre><code language="language-java" class="language-java">List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;, &#34;David&#34;);

// Single condition
List&lt;String&gt; longNames = names.stream()
    .filter(name -&gt; name.length() &gt; 3)
    .collect(Collectors.toList());

// Multiple filters (can chain or combine)
List&lt;String&gt; filtered = names.stream()
    .filter(name -&gt; name.length() &gt; 3)
    .filter(name -&gt; name.startsWith(&#34;C&#34;))
    .collect(Collectors.toList());
// Result: [Charlie]
</code></pre>
<h2 is-upgraded>map()</h2>
<p>Transform each element:</p>
<pre><code language="language-java" class="language-java">List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;);

// String to Integer
List&lt;Integer&gt; lengths = names.stream()
    .map(String::length)
    .collect(Collectors.toList());
// [5, 3, 7]

// Object transformation
class Person {
    String name;
    int age;
    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

List&lt;Person&gt; people = Arrays.asList(
    new Person(&#34;Alice&#34;, 25),
    new Person(&#34;Bob&#34;, 30)
);

List&lt;String&gt; personNames = people.stream()
    .map(p -&gt; p.name)  // or Person::getName if using getter
    .collect(Collectors.toList());
</code></pre>
<h2 is-upgraded>flatMap()</h2>
<p>Flatten nested structures:</p>
<pre><code language="language-java" class="language-java">// List of lists
List&lt;List&lt;Integer&gt;&gt; nested = Arrays.asList(
    Arrays.asList(1, 2, 3),
    Arrays.asList(4, 5),
    Arrays.asList(6, 7, 8, 9)
);

// Flatten to single list
List&lt;Integer&gt; flattened = nested.stream()
    .flatMap(list -&gt; list.stream())
    .collect(Collectors.toList());
// [1, 2, 3, 4, 5, 6, 7, 8, 9]

// Split strings and flatten
List&lt;String&gt; sentences = Arrays.asList(
    &#34;Hello World&#34;,
    &#34;Java Streams&#34;,
    &#34;Functional Programming&#34;
);

List&lt;String&gt; words = sentences.stream()
    .flatMap(sentence -&gt; Arrays.stream(sentence.split(&#34; &#34;)))
    .collect(Collectors.toList());
// [Hello, World, Java, Streams, Functional, Programming]

// Objects with collections
class Department {
    String name;
    List&lt;String&gt; employees;
    Department(String name, List&lt;String&gt; employees) {
        this.name = name;
        this.employees = employees;
    }
}

List&lt;Department&gt; departments = Arrays.asList(
    new Department(&#34;IT&#34;, Arrays.asList(&#34;Alice&#34;, &#34;Bob&#34;)),
    new Department(&#34;HR&#34;, Arrays.asList(&#34;Charlie&#34;, &#34;David&#34;))
);

List&lt;String&gt; allEmployees = departments.stream()
    .flatMap(dept -&gt; dept.employees.stream())
    .collect(Collectors.toList());
</code></pre>
<h2 is-upgraded>sorted()</h2>
<pre><code language="language-java" class="language-java">List&lt;Integer&gt; numbers = Arrays.asList(5, 2, 8, 1, 9);

// Natural order
List&lt;Integer&gt; sorted = numbers.stream()
    .sorted()
    .collect(Collectors.toList());

// Custom comparator
List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;bob&#34;, &#34;CHARLIE&#34;);

// Case-insensitive sort
List&lt;String&gt; sortedNames = names.stream()
    .sorted(String::compareToIgnoreCase)
    .collect(Collectors.toList());

// Complex object sorting
class Product {
    String name;
    double price;
    Product(String name, double price) {
        this.name = name;
        this.price = price;
    }
}

List&lt;Product&gt; products = Arrays.asList(
    new Product(&#34;Laptop&#34;, 1000),
    new Product(&#34;Mouse&#34;, 25),
    new Product(&#34;Keyboard&#34;, 75)
);

// Sort by price
List&lt;Product&gt; byPrice = products.stream()
    .sorted(Comparator.comparingDouble(p -&gt; p.price))
    .collect(Collectors.toList());

// Sort by multiple fields
List&lt;Product&gt; sorted = products.stream()
    .sorted(Comparator.comparing((Product p) -&gt; p.price)
                      .thenComparing(p -&gt; p.name))
    .collect(Collectors.toList());
</code></pre>
<h2 is-upgraded>distinct() and limit()</h2>
<pre><code language="language-java" class="language-java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 5, 5);

// Remove duplicates
List&lt;Integer&gt; unique = numbers.stream()
    .distinct()
    .collect(Collectors.toList());
// [1, 2, 3, 4, 5]

// Get top 3 unique values
List&lt;Integer&gt; topThree = numbers.stream()
    .distinct()
    .sorted(Comparator.reverseOrder())
    .limit(3)
    .collect(Collectors.toList());
// [5, 4, 3]

// Pagination simulation
int page = 2;
int pageSize = 10;
List&lt;Integer&gt; paginatedResults = largeList.stream()
    .skip((page - 1) * pageSize)
    .limit(pageSize)
    .collect(Collectors.toList());
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Terminal Operations" duration="10">
        <p>Terminal operations produce a result or side effect and close the stream.</p>
<h2 is-upgraded>collect()</h2>
<p>Most versatile terminal operation:</p>
<pre><code language="language-java" class="language-java">List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;);

// To List
List&lt;String&gt; list = names.stream()
    .collect(Collectors.toList());

// To Set
Set&lt;String&gt; set = names.stream()
    .collect(Collectors.toSet());

// To specific collection
ArrayList&lt;String&gt; arrayList = names.stream()
    .collect(Collectors.toCollection(ArrayList::new));

// To Map
List&lt;Person&gt; people = /* ... */;
Map&lt;String, Person&gt; map = people.stream()
    .collect(Collectors.toMap(
        p -&gt; p.name,     // key
        p -&gt; p           // value
    ));

// To String
String joined = names.stream()
    .collect(Collectors.joining(&#34;, &#34;));
// &#34;Alice, Bob, Charlie&#34;

String withPrefixSuffix = names.stream()
    .collect(Collectors.joining(&#34;, &#34;, &#34;[&#34;, &#34;]&#34;));
// &#34;[Alice, Bob, Charlie]&#34;
</code></pre>
<h2 is-upgraded>forEach() and forEachOrdered()</h2>
<pre><code language="language-java" class="language-java">List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;);

// Process each element
names.stream()
    .forEach(name -&gt; System.out.println(name));

// Method reference
names.stream()
    .forEach(System.out::println);

// forEachOrdered (maintains order in parallel streams)
names.parallelStream()
    .forEachOrdered(System.out::println);
</code></pre>
<aside class="warning"><p><strong>Warning: </strong><code>forEach()</code> order is not guaranteed in parallel streams. Use <code>forEachOrdered()</code> when order matters.</p>
</aside>
<h2 is-upgraded>count(), min(), max()</h2>
<pre><code language="language-java" class="language-java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);

// Count elements
long count = numbers.stream()
    .filter(n -&gt; n % 2 == 0)
    .count();
// 2

// Find minimum
Optional&lt;Integer&gt; min = numbers.stream()
    .min(Integer::compareTo);
System.out.println(min.get());  // 1

// Find maximum
Optional&lt;Integer&gt; max = numbers.stream()
    .max(Integer::compareTo);
System.out.println(max.get());  // 5

// Custom comparator
List&lt;String&gt; words = Arrays.asList(&#34;a&#34;, &#34;abc&#34;, &#34;ab&#34;);
Optional&lt;String&gt; longest = words.stream()
    .max(Comparator.comparingInt(String::length));
System.out.println(longest.get());  // &#34;abc&#34;
</code></pre>
<h2 is-upgraded>reduce()</h2>
<p>Combine elements into a single result:</p>
<pre><code language="language-java" class="language-java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);

// Sum
Optional&lt;Integer&gt; sum = numbers.stream()
    .reduce((a, b) -&gt; a + b);
System.out.println(sum.get());  // 15

// Sum with identity
Integer sum2 = numbers.stream()
    .reduce(0, (a, b) -&gt; a + b);
System.out.println(sum2);  // 15

// Product
Integer product = numbers.stream()
    .reduce(1, (a, b) -&gt; a * b);
System.out.println(product);  // 120

// String concatenation
List&lt;String&gt; words = Arrays.asList(&#34;Hello&#34;, &#34;World&#34;, &#34;!&#34;);
String sentence = words.stream()
    .reduce(&#34;&#34;, (a, b) -&gt; a + &#34; &#34; + b);
System.out.println(sentence.trim());  // &#34;Hello World !&#34;

// Find maximum
Optional&lt;Integer&gt; max = numbers.stream()
    .reduce((a, b) -&gt; a &gt; b ? a : b);

// Complex reduction
class Transaction {
    double amount;
    Transaction(double amount) {
        this.amount = amount;
    }
}

List&lt;Transaction&gt; transactions = Arrays.asList(
    new Transaction(100),
    new Transaction(200),
    new Transaction(300)
);

double total = transactions.stream()
    .map(t -&gt; t.amount)
    .reduce(0.0, Double::sum);
</code></pre>
<h2 is-upgraded>anyMatch(), allMatch(), noneMatch()</h2>
<pre><code language="language-java" class="language-java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5);

// Check if any element matches
boolean hasEven = numbers.stream()
    .anyMatch(n -&gt; n % 2 == 0);
System.out.println(hasEven);  // true

// Check if all elements match
boolean allPositive = numbers.stream()
    .allMatch(n -&gt; n &gt; 0);
System.out.println(allPositive);  // true

// Check if no elements match
boolean noNegative = numbers.stream()
    .noneMatch(n -&gt; n &lt; 0);
System.out.println(noNegative);  // true

// Short-circuit evaluation
boolean found = largeList.stream()
    .anyMatch(item -&gt; expensiveCheck(item));
// Stops as soon as one match is found
</code></pre>
<h2 is-upgraded>findFirst() and findAny()</h2>
<pre><code language="language-java" class="language-java">List&lt;String&gt; names = Arrays.asList(&#34;Alice&#34;, &#34;Bob&#34;, &#34;Charlie&#34;);

// Find first element
Optional&lt;String&gt; first = names.stream()
    .filter(name -&gt; name.startsWith(&#34;C&#34;))
    .findFirst();
System.out.println(first.get());  // &#34;Charlie&#34;

// Find any element (useful for parallel streams)
Optional&lt;String&gt; any = names.parallelStream()
    .filter(name -&gt; name.length() &gt; 3)
    .findAny();
System.out.println(any.get());  // Any matching name
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Advanced Collectors" duration="15">
        <p>Collectors provide powerful ways to accumulate stream elements into collections and perform complex aggregations.</p>
<h2 is-upgraded>Grouping Operations</h2>
<p><strong>groupingBy() - Group by Property:</strong></p>
<pre><code language="language-java" class="language-java">class Employee {
    String name;
    String department;
    double salary;

    Employee(String name, String department, double salary) {
        this.name = name;
        this.department = department;
        this.salary = salary;
    }

    // Getters
    public String getName() { return name; }
    public String getDepartment() { return department; }
    public double getSalary() { return salary; }
}

List&lt;Employee&gt; employees = Arrays.asList(
    new Employee(&#34;Alice&#34;, &#34;IT&#34;, 80000),
    new Employee(&#34;Bob&#34;, &#34;IT&#34;, 75000),
    new Employee(&#34;Charlie&#34;, &#34;HR&#34;, 65000),
    new Employee(&#34;David&#34;, &#34;HR&#34;, 70000),
    new Employee(&#34;Eve&#34;, &#34;IT&#34;, 90000)
);

// Group by department
Map&lt;String, List&lt;Employee&gt;&gt; byDepartment = employees.stream()
    .collect(Collectors.groupingBy(Employee::getDepartment));

System.out.println(byDepartment);
// {IT=[Alice, Bob, Eve], HR=[Charlie, David]}

// Group and count
Map&lt;String, Long&gt; countByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.counting()
    ));
System.out.println(countByDept);
// {IT=3, HR=2}

// Group and calculate average salary
Map&lt;String, Double&gt; avgSalaryByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.averagingDouble(Employee::getSalary)
    ));
System.out.println(avgSalaryByDept);
// {IT=81666.67, HR=67500.0}

// Group and collect names
Map&lt;String, List&lt;String&gt;&gt; namesByDept = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.mapping(Employee::getName, Collectors.toList())
    ));
System.out.println(namesByDept);
// {IT=[Alice, Bob, Eve], HR=[Charlie, David]}

// Multi-level grouping
class Employee {
    String department;
    String level;  // Junior, Senior, etc.
    // ... other fields
}

Map&lt;String, Map&lt;String, List&lt;Employee&gt;&gt;&gt; multiLevel = employees.stream()
    .collect(Collectors.groupingBy(
        Employee::getDepartment,
        Collectors.groupingBy(Employee::getLevel)
    ));
</code></pre>
<h2 is-upgraded>Partitioning</h2>
<p>Split stream into two groups based on a predicate:</p>
<pre><code language="language-java" class="language-java">List&lt;Employee&gt; employees = /* ... */;

// Partition by salary threshold
Map&lt;Boolean, List&lt;Employee&gt;&gt; partitioned = employees.stream()
    .collect(Collectors.partitioningBy(e -&gt; e.getSalary() &gt; 75000));

List&lt;Employee&gt; highPaid = partitioned.get(true);
List&lt;Employee&gt; lowPaid = partitioned.get(false);

// Partition and count
Map&lt;Boolean, Long&gt; counts = employees.stream()
    .collect(Collectors.partitioningBy(
        e -&gt; e.getSalary() &gt; 75000,
        Collectors.counting()
    ));
System.out.println(&#34;High paid: &#34; + counts.get(true));
System.out.println(&#34;Low paid: &#34; + counts.get(false));
</code></pre>
<h2 is-upgraded>Statistical Collectors</h2>
<pre><code language="language-java" class="language-java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Summarizing statistics
IntSummaryStatistics stats = numbers.stream()
    .collect(Collectors.summarizingInt(Integer::intValue));

System.out.println(&#34;Count: &#34; + stats.getCount());      // 10
System.out.println(&#34;Sum: &#34; + stats.getSum());          // 55
System.out.println(&#34;Min: &#34; + stats.getMin());          // 1
System.out.println(&#34;Max: &#34; + stats.getMax());          // 10
System.out.println(&#34;Average: &#34; + stats.getAverage());  // 5.5

// Double statistics
List&lt;Employee&gt; employees = /* ... */;
DoubleSummaryStatistics salaryStats = employees.stream()
    .collect(Collectors.summarizingDouble(Employee::getSalary));

System.out.println(&#34;Avg Salary: &#34; + salaryStats.getAverage());
System.out.println(&#34;Total Payroll: &#34; + salaryStats.getSum());
</code></pre>
<h2 is-upgraded>Custom Collectors</h2>
<pre><code language="language-java" class="language-java">// Joining with custom formatting
String formatted = employees.stream()
    .map(Employee::getName)
    .collect(Collectors.joining(
        &#34;, &#34;,              // delimiter
        &#34;Employees: [&#34;,    // prefix
        &#34;]&#34;                // suffix
    ));
// &#34;Employees: [Alice, Bob, Charlie, David, Eve]&#34;

// Collect to Map with collision handling
Map&lt;String, Employee&gt; employeeMap = employees.stream()
    .collect(Collectors.toMap(
        Employee::getName,           // key
        e -&gt; e,                      // value
        (existing, replacement) -&gt; existing  // collision handler
    ));

// toMap with custom value
Map&lt;String, Double&gt; salaryMap = employees.stream()
    .collect(Collectors.toMap(
        Employee::getName,
        Employee::getSalary
    ));

// Collecting then transforming
List&lt;String&gt; upperNames = employees.stream()
    .collect(Collectors.collectingAndThen(
        Collectors.toList(),
        list -&gt; {
            return list.stream()
                .map(Employee::getName)
                .map(String::toUpperCase)
                .collect(Collectors.toList());
        }
    ));
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Build Sales Analytics Application" duration="20">
        <p>Now let&#39;s build a comprehensive sales analytics system using everything we&#39;ve learned!</p>
<h2 is-upgraded>Project Structure</h2>
<p>Create <code>SalesAnalytics.java</code>:</p>
<pre><code language="language-java" class="language-java">import java.time.LocalDate;
import java.util.*;
import java.util.stream.*;

class Sale {
    private String id;
    private String product;
    private String category;
    private double amount;
    private int quantity;
    private LocalDate date;
    private String region;
    private String salesperson;

    public Sale(String id, String product, String category, double amount,
                int quantity, LocalDate date, String region, String salesperson) {
        this.id = id;
        this.product = product;
        this.category = category;
        this.amount = amount;
        this.quantity = quantity;
        this.date = date;
        this.region = region;
        this.salesperson = salesperson;
    }

    // Getters
    public String getId() { return id; }
    public String getProduct() { return product; }
    public String getCategory() { return category; }
    public double getAmount() { return amount; }
    public int getQuantity() { return quantity; }
    public LocalDate getDate() { return date; }
    public String getRegion() { return region; }
    public String getSalesperson() { return salesperson; }

    @Override
    public String toString() {
        return String.format(&#34;%s: %s ($%.2f)&#34;, id, product, amount);
    }
}

public class SalesAnalytics {
    private List&lt;Sale&gt; sales;

    public SalesAnalytics() {
        this.sales = generateSampleData();
    }

    private List&lt;Sale&gt; generateSampleData() {
        return Arrays.asList(
            new Sale(&#34;S001&#34;, &#34;Laptop&#34;, &#34;Electronics&#34;, 1200.00, 2,
                     LocalDate.of(2024, 1, 15), &#34;North&#34;, &#34;Alice&#34;),
            new Sale(&#34;S002&#34;, &#34;Mouse&#34;, &#34;Electronics&#34;, 25.00, 10,
                     LocalDate.of(2024, 1, 16), &#34;South&#34;, &#34;Bob&#34;),
            new Sale(&#34;S003&#34;, &#34;Desk&#34;, &#34;Furniture&#34;, 450.00, 3,
                     LocalDate.of(2024, 1, 17), &#34;East&#34;, &#34;Charlie&#34;),
            new Sale(&#34;S004&#34;, &#34;Chair&#34;, &#34;Furniture&#34;, 180.00, 5,
                     LocalDate.of(2024, 1, 18), &#34;West&#34;, &#34;Alice&#34;),
            new Sale(&#34;S005&#34;, &#34;Monitor&#34;, &#34;Electronics&#34;, 300.00, 4,
                     LocalDate.of(2024, 1, 19), &#34;North&#34;, &#34;David&#34;),
            new Sale(&#34;S006&#34;, &#34;Keyboard&#34;, &#34;Electronics&#34;, 75.00, 8,
                     LocalDate.of(2024, 1, 20), &#34;South&#34;, &#34;Bob&#34;),
            new Sale(&#34;S007&#34;, &#34;Bookshelf&#34;, &#34;Furniture&#34;, 200.00, 2,
                     LocalDate.of(2024, 2, 1), &#34;East&#34;, &#34;Charlie&#34;),
            new Sale(&#34;S008&#34;, &#34;Laptop&#34;, &#34;Electronics&#34;, 1400.00, 1,
                     LocalDate.of(2024, 2, 5), &#34;North&#34;, &#34;Alice&#34;),
            new Sale(&#34;S009&#34;, &#34;Desk Lamp&#34;, &#34;Electronics&#34;, 40.00, 15,
                     LocalDate.of(2024, 2, 10), &#34;West&#34;, &#34;David&#34;),
            new Sale(&#34;S010&#34;, &#34;Office Chair&#34;, &#34;Furniture&#34;, 250.00, 6,
                     LocalDate.of(2024, 2, 15), &#34;South&#34;, &#34;Bob&#34;)
        );
    }

    // 1. Total Revenue
    public double calculateTotalRevenue() {
        return sales.stream()
            .mapToDouble(Sale::getAmount)
            .sum();
    }

    // 2. Revenue by Category
    public Map&lt;String, Double&gt; revenueByCategory() {
        return sales.stream()
            .collect(Collectors.groupingBy(
                Sale::getCategory,
                Collectors.summingDouble(Sale::getAmount)
            ));
    }

    // 3. Top Products by Revenue
    public List&lt;Map.Entry&lt;String, Double&gt;&gt; topProducts(int n) {
        return sales.stream()
            .collect(Collectors.groupingBy(
                Sale::getProduct,
                Collectors.summingDouble(Sale::getAmount)
            ))
            .entrySet()
            .stream()
            .sorted(Map.Entry.&lt;String, Double&gt;comparingByValue().reversed())
            .limit(n)
            .collect(Collectors.toList());
    }

    // 4. Sales by Region
    public Map&lt;String, Long&gt; salesCountByRegion() {
        return sales.stream()
            .collect(Collectors.groupingBy(
                Sale::getRegion,
                Collectors.counting()
            ));
    }

    // 5. Average Sale Amount by Salesperson
    public Map&lt;String, Double&gt; averageSalesBySalesperson() {
        return sales.stream()
            .collect(Collectors.groupingBy(
                Sale::getSalesperson,
                Collectors.averagingDouble(Sale::getAmount)
            ));
    }

    // 6. High-Value Sales (above threshold)
    public List&lt;Sale&gt; getHighValueSales(double threshold) {
        return sales.stream()
            .filter(sale -&gt; sale.getAmount() &gt; threshold)
            .sorted(Comparator.comparingDouble(Sale::getAmount).reversed())
            .collect(Collectors.toList());
    }

    // 7. Monthly Revenue
    public Map&lt;Integer, Double&gt; revenueByMonth() {
        return sales.stream()
            .collect(Collectors.groupingBy(
                sale -&gt; sale.getDate().getMonthValue(),
                Collectors.summingDouble(Sale::getAmount)
            ));
    }

    // 8. Product Performance Statistics
    public void productStatistics() {
        Map&lt;String, DoubleSummaryStatistics&gt; stats = sales.stream()
            .collect(Collectors.groupingBy(
                Sale::getCategory,
                Collectors.summarizingDouble(Sale::getAmount)
            ));

        stats.forEach((category, stat) -&gt; {
            System.out.println(&#34;\nCategory: &#34; + category);
            System.out.printf(&#34;  Count: %d%n&#34;, stat.getCount());
            System.out.printf(&#34;  Total: $%.2f%n&#34;, stat.getSum());
            System.out.printf(&#34;  Average: $%.2f%n&#34;, stat.getAverage());
            System.out.printf(&#34;  Min: $%.2f%n&#34;, stat.getMin());
            System.out.printf(&#34;  Max: $%.2f%n&#34;, stat.getMax());
        });
    }

    // 9. Top Salesperson
    public Map.Entry&lt;String, Double&gt; topSalesperson() {
        return sales.stream()
            .collect(Collectors.groupingBy(
                Sale::getSalesperson,
                Collectors.summingDouble(Sale::getAmount)
            ))
            .entrySet()
            .stream()
            .max(Map.Entry.comparingByValue())
            .orElse(null);
    }

    // 10. Sales Distribution (Partition by amount)
    public Map&lt;Boolean, List&lt;Sale&gt;&gt; partitionSales(double threshold) {
        return sales.stream()
            .collect(Collectors.partitioningBy(
                sale -&gt; sale.getAmount() &gt;= threshold
            ));
    }

    // 11. Complex Query: Region-Category Matrix
    public Map&lt;String, Map&lt;String, Double&gt;&gt; regionCategoryMatrix() {
        return sales.stream()
            .collect(Collectors.groupingBy(
                Sale::getRegion,
                Collectors.groupingBy(
                    Sale::getCategory,
                    Collectors.summingDouble(Sale::getAmount)
                )
            ));
    }

    // 12. Find sales by multiple criteria
    public List&lt;Sale&gt; findSales(String category, String region, double minAmount) {
        return sales.stream()
            .filter(sale -&gt; sale.getCategory().equals(category))
            .filter(sale -&gt; sale.getRegion().equals(region))
            .filter(sale -&gt; sale.getAmount() &gt;= minAmount)
            .collect(Collectors.toList());
    }

    public void runAnalytics() {
        System.out.println(&#34;=== SALES ANALYTICS DASHBOARD ===\n&#34;);

        // Total Revenue
        System.out.printf(&#34;Total Revenue: $%.2f%n%n&#34;, calculateTotalRevenue());

        // Revenue by Category
        System.out.println(&#34;Revenue by Category:&#34;);
        revenueByCategory().forEach((category, revenue) -&gt;
            System.out.printf(&#34;  %s: $%.2f%n&#34;, category, revenue)
        );

        // Top 3 Products
        System.out.println(&#34;\nTop 3 Products:&#34;);
        topProducts(3).forEach(entry -&gt;
            System.out.printf(&#34;  %s: $%.2f%n&#34;, entry.getKey(), entry.getValue())
        );

        // Sales by Region
        System.out.println(&#34;\nSales Count by Region:&#34;);
        salesCountByRegion().forEach((region, count) -&gt;
            System.out.printf(&#34;  %s: %d sales%n&#34;, region, count)
        );

        // Average by Salesperson
        System.out.println(&#34;\nAverage Sale by Salesperson:&#34;);
        averageSalesBySalesperson().forEach((person, avg) -&gt;
            System.out.printf(&#34;  %s: $%.2f%n&#34;, person, avg)
        );

        // High-value sales
        System.out.println(&#34;\nHigh-Value Sales (&gt;$500):&#34;);
        getHighValueSales(500.0).forEach(sale -&gt;
            System.out.println(&#34;  &#34; + sale)
        );

        // Monthly revenue
        System.out.println(&#34;\nRevenue by Month:&#34;);
        revenueByMonth().forEach((month, revenue) -&gt;
            System.out.printf(&#34;  Month %d: $%.2f%n&#34;, month, revenue)
        );

        // Product statistics
        productStatistics();

        // Top salesperson
        Map.Entry&lt;String, Double&gt; top = topSalesperson();
        System.out.printf(&#34;%nTop Salesperson: %s ($%.2f)%n&#34;,
            top.getKey(), top.getValue());

        // Sales partition
        System.out.println(&#34;\nSales Partition (threshold: $200):&#34;);
        Map&lt;Boolean, List&lt;Sale&gt;&gt; partitioned = partitionSales(200.0);
        System.out.println(&#34;  High-value sales: &#34; + partitioned.get(true).size());
        System.out.println(&#34;  Low-value sales: &#34; + partitioned.get(false).size());

        // Region-Category Matrix
        System.out.println(&#34;\nRegion-Category Revenue Matrix:&#34;);
        regionCategoryMatrix().forEach((region, categories) -&gt; {
            System.out.println(&#34;  &#34; + region + &#34;:&#34;);
            categories.forEach((category, revenue) -&gt;
                System.out.printf(&#34;    %s: $%.2f%n&#34;, category, revenue)
            );
        });
    }

    public static void main(String[] args) {
        SalesAnalytics analytics = new SalesAnalytics();
        analytics.runAnalytics();
    }
}
</code></pre>
<h2 is-upgraded>Run the Application</h2>
<pre>$ javac SalesAnalytics.java
$ java SalesAnalytics
</pre>
<p><strong>Expected Output:</strong></p>
<pre><code>=== SALES ANALYTICS DASHBOARD ===

Total Revenue: $4120.00

Revenue by Category:
  Electronics: $3040.00
  Furniture: $1080.00

Top 3 Products:
  Laptop: $2600.00
  Office Chair: $1500.00
  Desk: $1350.00

Sales Count by Region:
  North: 3 sales
  South: 3 sales
  East: 2 sales
  West: 2 sales

...
</code></pre>
<aside class="special"><p><strong>Great Job!</strong> You&#39;ve built a production-quality analytics engine using pure functional programming!</p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Parallel Streams" duration="8">
        <p>Parallel streams split data into multiple chunks and process them concurrently on multiple CPU cores.</p>
<h2 is-upgraded>Creating Parallel Streams</h2>
<pre><code language="language-java" class="language-java">List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);

// Method 1: From sequential stream
Stream&lt;Integer&gt; parallelStream = numbers.stream().parallel();

// Method 2: Direct parallel stream
Stream&lt;Integer&gt; parallelStream2 = numbers.parallelStream();

// Convert back to sequential
Stream&lt;Integer&gt; sequential = parallelStream.sequential();
</code></pre>
<h2 is-upgraded>Performance Comparison</h2>
<pre><code language="language-java" class="language-java">import java.util.*;
import java.util.stream.*;

public class ParallelStreamDemo {
    public static void main(String[] args) {
        List&lt;Integer&gt; numbers = IntStream.rangeClosed(1, 10_000_000)
            .boxed()
            .collect(Collectors.toList());

        // Sequential processing
        long startSeq = System.currentTimeMillis();
        long sumSeq = numbers.stream()
            .filter(n -&gt; n % 2 == 0)
            .mapToLong(n -&gt; n * n)
            .sum();
        long endSeq = System.currentTimeMillis();

        System.out.println(&#34;Sequential Result: &#34; + sumSeq);
        System.out.println(&#34;Sequential Time: &#34; + (endSeq - startSeq) + &#34;ms&#34;);

        // Parallel processing
        long startPar = System.currentTimeMillis();
        long sumPar = numbers.parallelStream()
            .filter(n -&gt; n % 2 == 0)
            .mapToLong(n -&gt; n * n)
            .sum();
        long endPar = System.currentTimeMillis();

        System.out.println(&#34;\nParallel Result: &#34; + sumPar);
        System.out.println(&#34;Parallel Time: &#34; + (endPar - startPar) + &#34;ms&#34;);

        double speedup = (double)(endSeq - startSeq) / (endPar - startPar);
        System.out.printf(&#34;\nSpeedup: %.2fx%n&#34;, speedup);
    }
}
</code></pre>
<h2 is-upgraded>When to Use Parallel Streams</h2>
<p><strong>Good Candidates:</strong></p>
<ul>
<li>Large datasets (thousands+ elements)</li>
<li>CPU-intensive operations</li>
<li>Independent operations (no shared state)</li>
<li>Operations that benefit from parallelization</li>
</ul>
<pre><code language="language-java" class="language-java">// Good: CPU-intensive, large dataset
List&lt;ComplexObject&gt; results = hugeList.parallelStream()
    .map(obj -&gt; expensiveComputation(obj))
    .collect(Collectors.toList());

// Good: Simple aggregation
long sum = largeList.parallelStream()
    .mapToLong(Integer::longValue)
    .sum();
</code></pre>
<p><strong>Poor Candidates:</strong></p>
<ul>
<li>Small datasets (overhead &gt; benefit)</li>
<li>I/O operations (thread contention)</li>
<li>Order-dependent operations</li>
<li>Shared mutable state</li>
</ul>
<pre><code language="language-java" class="language-java">// Bad: Small dataset
List&lt;Integer&gt; small = Arrays.asList(1, 2, 3, 4, 5);
small.parallelStream().forEach(System.out::println);  // Overkill

// Bad: Order matters
List&lt;String&gt; ordered = list.parallelStream()
    .sorted()
    .collect(Collectors.toList());  // Use sequential

// Bad: Shared mutable state
List&lt;Integer&gt; result = new ArrayList&lt;&gt;();  // Not thread-safe!
numbers.parallelStream()
    .forEach(n -&gt; result.add(n * 2));  // WRONG! Race condition
</code></pre>
<aside class="warning"><p><strong>Warning:</strong> Parallel streams use the common ForkJoinPool. Blocking operations can starve other parallel streams in your application.</p>
</aside>
<h2 is-upgraded>Thread-Safe Operations</h2>
<pre><code language="language-java" class="language-java">// Safe: Collectors are thread-safe
List&lt;Integer&gt; safe = numbers.parallelStream()
    .map(n -&gt; n * 2)
    .collect(Collectors.toList());

// Safe: Reduction operations
int sum = numbers.parallelStream()
    .reduce(0, Integer::sum);

// Unsafe: Shared mutable state
List&lt;Integer&gt; unsafe = new ArrayList&lt;&gt;();
numbers.parallelStream()
    .forEach(unsafe::add);  // Race condition!

// Safe alternative: Use thread-safe collection
List&lt;Integer&gt; safe = Collections.synchronizedList(new ArrayList&lt;&gt;());
numbers.parallelStream()
    .forEach(safe::add);

// Better: Use collectors
List&lt;Integer&gt; best = numbers.parallelStream()
    .collect(Collectors.toList());
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Conclusion" duration="2">
        <p>Congratulations! 🎉 You&#39;ve mastered functional programming and the Stream API!</p>
<h2 is-upgraded>What You&#39;ve Learned</h2>
<ul>
<li>✅ <strong>Functional Programming:</strong> Paradigm shift from imperative to declarative</li>
<li>✅ <strong>Lambda Expressions:</strong> Concise syntax for functional interfaces</li>
<li>✅ <strong>Functional Interfaces:</strong> Predicate, Function, Consumer, Supplier, BiFunction</li>
<li>✅ <strong>Method References:</strong> Shorthand for lambdas (::)</li>
<li>✅ <strong>Stream API:</strong> Powerful data processing pipelines</li>
<li>✅ <strong>Intermediate Operations:</strong> filter, map, flatMap, sorted, distinct</li>
<li>✅ <strong>Terminal Operations:</strong> collect, forEach, reduce, count, min, max</li>
<li>✅ <strong>Advanced Collectors:</strong> groupingBy, partitioningBy, statistics</li>
<li>✅ <strong>Parallel Streams:</strong> Multi-core processing for performance</li>
</ul>
<h2 is-upgraded>Key Takeaways</h2>
<ol type="1">
<li><strong>Functional style</strong> is declarative - describe <strong>what</strong>, not <strong>how</strong></li>
<li><strong>Lambdas</strong> make code concise and expressive</li>
<li><strong>Streams</strong> enable powerful data transformations</li>
<li><strong>Collectors</strong> provide sophisticated aggregation capabilities</li>
<li><strong>Parallel streams</strong> can boost performance but require careful use</li>
<li><strong>Immutability</strong> prevents bugs and enables safe parallelization</li>
</ol>
<h2 is-upgraded>Best Practices</h2>
<ul>
<li>Use method references when lambdas just call existing methods</li>
<li>Chain stream operations for readability</li>
<li>Avoid side effects in stream operations</li>
<li>Use parallel streams only for large datasets and CPU-intensive tasks</li>
<li>Prefer collectors over manual accumulation</li>
<li>Keep lambda expressions short and focused</li>
</ul>
<h2 is-upgraded>Next Steps</h2>
<p>Ready for more modern Java? Continue to:</p>
<ul>
<li><strong>Codelab 2.2:</strong> Optional, Date/Time &amp; Modern Java Features</li>
<li><strong>Codelab 2.3:</strong> Asynchronous Programming with CompletableFuture</li>
<li><strong>Codelab 2.4:</strong> Logging with Log4j</li>
</ul>
<h2 is-upgraded>Practice Exercises</h2>
<ol type="1">
<li><strong>Order Processing:</strong> Process orders with discounts, tax calculations, and grouping</li>
<li><strong>Log Analyzer:</strong> Parse log files and generate statistics by severity</li>
<li><strong>Student Grading:</strong> Calculate grades, averages, and rankings</li>
<li><strong>E-commerce Reports:</strong> Product recommendations based on purchase history</li>
<li><strong>Performance Benchmark:</strong> Compare sequential vs parallel for various datasets</li>
</ol>
<h2 is-upgraded>Additional Resources</h2>
<ul>
<li><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/stream/package-summary.html" target="_blank">Java Stream API Documentation</a></li>
<li><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/function/package-summary.html" target="_blank">Java Functional Interfaces</a></li>
<li><a href="https://www.oreilly.com/library/view/effective-java/9780134686097/" target="_blank">Effective Java by Joshua Bloch</a> - Chapter on Lambdas and Streams</li>
</ul>
<aside class="special"><p><strong>Excellent Work!</strong> You now have the skills to write modern, efficient Java code. The functional programming techniques you learned are used extensively in Spring Boot and microservices!</p>
</aside>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.11.1/build/highlight.min.js"></script>
  <script src="https://unpkg.com/highlightjs-copy/dist/highlightjs-copy.min.js"></script>
  <script>
    hljs.highlightAll();
    hljs.addPlugin(new CopyButtonPlugin({ autohide: false}));
    
    
    document.addEventListener('DOMContentLoaded', function() {
      const homeUrl = "\/springboot_course\/";
      const arrowBack = document.getElementById('arrow-back');
      const doneBtn = document.getElementById('done');
      if (arrowBack) arrowBack.href = homeUrl;
      if (doneBtn) doneBtn.href = homeUrl;
    });
    
  </script>

</body>
</html>
